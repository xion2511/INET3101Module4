# INET3101Module4

Problem Statement:
This module extends my previous Colossus Airlines reservation program so that seat assignments are not lost when the program ends. The application still manages two flights per day—Outbound and Inbound—with twenty-four seats each, and it still presents a first-level menu to choose a flight and a second-level menu to show the number of empty seats, list the empty seat numbers, display an alphabetical list of assigned seats, assign a customer to a seat, delete an assignment, or return to the main menu. The new requirement is persistence: the program must store reservation data in a file and, on the next run, automatically load any existing data before showing the menus.
Describe the Solution:
My solution retains the same data model as before by keeping two Flight objects, each containing an array of twenty-four Seat structures that hold the seat ID, an assigned flag, and the passenger’s first and last names. At startup, the program initializes both flights to empty and then attempts to load data from a simple text file named colossus_data.txt. If the file is present and well-formed, the program restores all seats for both flights; if the file is missing or unreadable, it proceeds with empty flights. Whenever the user performs an operation that changes data—either assigning a seat or deleting one—the program saves both flights back to the same file so that the state persists across runs. The file format is deliberately human-readable: it begins with a small header and then lists twenty-four lines for the Outbound flight, followed by twenty-four lines for the Inbound flight, where each line contains the seat number, the assigned flag, and either the passenger’s names or placeholders for an empty seat. The alphabetical list is produced with a straightforward selection sort over an index array, which keeps seat numbers stable and stays within beginner-level material. Input is handled with scanf and a small helper that clears the remainder of the input line, which is consistent with the chapters on formatted I/O and basic validation.
Pros and Cons of my solution:
The primary advantage of this approach is its clarity and alignment with beginner topics: it uses arrays, structures, simple loops and conditionals, and standard file I/O calls without introducing dynamic memory or external libraries. The text file can be inspected or reset by hand, which makes testing and grading straightforward, and saving after each change reduces the chance of losing work. The main trade-offs are that the text format is not space-efficient, the parser assumes the file was created by the program and therefore does limited error recovery, and names remain single words with a fixed maximum length. These limitations are acceptable for the scope of the assignment and help keep the implementation easy to understand.
